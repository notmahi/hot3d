#!/usr/bin/env python3
"""
Script to visualize touch events from the JSON file generated by extract_fingertip_touching_timestamps.py.

This script reads the JSON file and visualizes objects (.glb meshes) and hands (skeletal representation) in a rerun window.
"""

import os
import sys
import json
import argparse
import random
from typing import List, Optional, Dict, Any
import numpy as np

import rerun as rr
from projectaria_tools.utils.rerun_helpers import ToTransform3D

import trimesh

from data_loaders.loader_hand_poses import Handedness
from data_loaders.loader_object_library import ObjectLibrary, load_object_library
from data_loaders.hand_common import LANDMARK_CONNECTIVITY
from projectaria_tools.core.sophus import SE3  # @manual


def matrix_to_se3(matrix: List[List[float]]) -> SE3:
    """Convert a 4x4 matrix (list of lists) to SE3."""
    matrix_np = np.array(matrix, dtype=np.float64)
    # Use SE3.from_matrix if available, otherwise convert via quaternion
    try:
        se3 = SE3.from_matrix(matrix_np)
        return se3
    except (AttributeError, TypeError):
        # Fallback: convert rotation matrix to quaternion
        rotation = matrix_np[:3, :3]
        translation = matrix_np[:3, 3]
        # Convert rotation matrix to quaternion
        # Using scipy or manual conversion
        try:
            from scipy.spatial.transform import Rotation
            rotation_obj = Rotation.from_matrix(rotation)
            quat = rotation_obj.as_quat()  # [x, y, z, w]
            
            # SE3.from_quat_and_translation expects (w, [x, y, z], translation)
            # Returns a tuple, we need the first element
            se3_result = SE3.from_quat_and_translation(
                float(quat[3]),  # w
                quat[:3],  # [x, y, z]
                translation
            )
            se3 = se3_result[0] if isinstance(se3_result, tuple) else se3_result
            return se3
        except ImportError:
            # Manual quaternion conversion if scipy not available
            # This is a simplified version - may not handle all edge cases
            trace = np.trace(rotation)
            if trace > 0:
                s = np.sqrt(trace + 1.0) * 2  # s=4*qw
                w = 0.25 * s
                x = (rotation[2, 1] - rotation[1, 2]) / s
                y = (rotation[0, 2] - rotation[2, 0]) / s
                z = (rotation[1, 0] - rotation[0, 1]) / s
            else:
                if rotation[0, 0] > rotation[1, 1] and rotation[0, 0] > rotation[2, 2]:
                    s = np.sqrt(1.0 + rotation[0, 0] - rotation[1, 1] - rotation[2, 2]) * 2
                    w = (rotation[2, 1] - rotation[1, 2]) / s
                    x = 0.25 * s
                    y = (rotation[0, 1] + rotation[1, 0]) / s
                    z = (rotation[0, 2] + rotation[2, 0]) / s
                elif rotation[1, 1] > rotation[2, 2]:
                    s = np.sqrt(1.0 + rotation[1, 1] - rotation[0, 0] - rotation[2, 2]) * 2
                    w = (rotation[0, 2] - rotation[2, 0]) / s
                    x = (rotation[0, 1] + rotation[1, 0]) / s
                    y = 0.25 * s
                    z = (rotation[1, 2] + rotation[2, 1]) / s
                else:
                    s = np.sqrt(1.0 + rotation[2, 2] - rotation[0, 0] - rotation[1, 1]) * 2
                    w = (rotation[1, 0] - rotation[0, 1]) / s
                    x = (rotation[0, 2] + rotation[2, 0]) / s
                    y = (rotation[1, 2] + rotation[2, 1]) / s
                    z = 0.25 * s
            
            # SE3.from_quat_and_translation returns a tuple, we need the first element
            se3_result = SE3.from_quat_and_translation(
                float(w),
                np.array([x, y, z]),
                translation
            )
            se3 = se3_result[0] if isinstance(se3_result, tuple) else se3_result
            return se3


def transform_points_to_world_coordinate_system(points: List[List[float]] | np.ndarray, hand_pose_se3: SE3) -> List[List[float]]:
    """Transform points to the world coordinate system."""
    np_points = np.array(points)
    shape_tuple = np_points.shape
    reshaped_points = np_points.reshape(-1, 3)
    np_points_homogeneous = np.hstack([reshaped_points, np.ones((reshaped_points.shape[0], 1))])
    np_points_world_homogeneous = hand_pose_se3.to_matrix() @ np_points_homogeneous.T
    print(f"np_points_world_homogeneous.shape: {np_points_world_homogeneous.shape}")
    np_points_world = np_points_world_homogeneous[:3, :].T
    return np_points_world.reshape(shape_tuple).tolist()

def load_touch_events(json_filepath: str) -> List[Dict[str, Any]]:
    """Load touch events from JSON file."""
    with open(json_filepath, "r") as f:
        events = json.load(f)
    return events


def visualize_touch_events(
    json_filepath: str,
    object_library_folder: str,
    mano_hand_model_path: Optional[str] = None,
    rrd_output_path: Optional[str] = None,
    num_events: Optional[int] = None,
):
    """
    Visualize touch events from JSON file in rerun.
    
    Args:
        json_filepath: Path to JSON file with touch events
        object_library_folder: Path to object library folder
        mano_hand_model_path: Path to MANO hand model directory
        rrd_output_path: Optional path to save .rrd file
        num_events: Optional number of events to visualize (None means all events)
    """
    # Load touch events
    print(f"Loading touch events from {json_filepath}...")
    touch_events = load_touch_events(json_filepath)
    print(f"Loaded {len(touch_events)} touch events")
    
    # Limit to N random events if specified
    if num_events is not None and num_events > 0:
        if num_events < len(touch_events):
            touch_events = random.sample(touch_events, num_events)
            print(f"Visualizing {num_events} random touch events")
        else:
            print(f"Visualizing all {len(touch_events)} touch events (requested {num_events})")
    
    # Load object library
    object_library = load_object_library(object_library_folder)
    
    # Initialize rerun
    rr.init("Touch Events Visualization", spawn=(rrd_output_path is None))
    if rrd_output_path is not None:
        print(f"Saving .rrd file to {rrd_output_path}")
        rr.save(rrd_output_path)
    
    # Get unique timestamps and sort them
    timestamps = sorted(set(event["timestamp_ns"] for event in touch_events))
    print(f"Visualizing {len(timestamps)} unique timestamps")
    
    # Group events by timestamp
    events_by_timestamp: Dict[int, List[Dict[str, Any]]] = {}
    for event in touch_events:
        ts = event["timestamp_ns"]
        if ts not in events_by_timestamp:
            events_by_timestamp[ts] = []
        events_by_timestamp[ts].append(event)
    
    # Visualize each timestamp
    for timestamp_ns in timestamps:
        events_at_timestamp = events_by_timestamp[timestamp_ns]
        
        # Set the timeline to this timestamp
        rr.set_time_nanos("timestamp", timestamp_ns)
        
        # Visualize each touch event at this timestamp
        for i, event in enumerate(events_at_timestamp):
            event_label = f"event_{i}"
            
            # Visualize object
            object_uid = event["object_uid"]
            object_name = object_library.object_id_to_name_dict.get(
                object_uid, f"object_{object_uid}"
            )
            object_name = f"{object_name}_{object_uid}"
            
            # Get object pose
            object_pose_matrix = event["object_pose_matrix"]
            T_world_object = matrix_to_se3(object_pose_matrix)
            
            # Log object pose
            rr.log(
                f"world/objects/{object_name}",
                ToTransform3D(T_world_object, False),
            )
            
            # Log object mesh (static asset, only once per object)
            object_cad_asset_filepath = ObjectLibrary.get_cad_asset_path(
                object_library_folderpath=object_library.asset_folder_name,
                object_id=object_uid,
            )
            
            rr.log(
                f"world/objects/{object_name}",
                rr.Asset3D(path=object_cad_asset_filepath),
            )
        
            # Log hand pose if available
            # Visualize hand as skeleton using landmarks
            landmarks = np.array(event["hand_landmarks"])
            handedness = event["handedness"]
            
            # Convert landmarks to connected lines using LANDMARK_CONNECTIVITY
            # This creates line strips for the skeletal representation
            # Format matches the reference: list of connections, each connection is a list of points
            points = [
                connections
                for connectivity in LANDMARK_CONNECTIVITY
                for connections in [
                    [landmarks[it].tolist() for it in connectivity]
                ]
            ]

            # Log skeletal representation as line strips
            rr.log(
                f"world/hands/{handedness}/joints",
                rr.LineStrips3D(points, radii=0.002),
            )
            
            # Optionally log landmarks as points for better visibility
            rr.log(
                f"world/hands/{handedness}/landmarks",
                rr.Points3D(landmarks, radii=0.005),
            )
                
    
    print("\nVisualization complete! The rerun viewer should be open.")
    print("You can navigate through timestamps using the timeline.")


def main():
    """Main function for command-line usage."""
    parser = argparse.ArgumentParser(
        description="Visualize touch events from JSON file in rerun"
    )
    parser.add_argument(
        "--json_filepath",
        type=str,
        help="Path to JSON file with touch events",
        default="data.json",
    )
    parser.add_argument(
        "--object_library_folder",
        type=str,
        help="Path to object library folder",
        default="/data/pickanything/hot3d/assets",
    )
    parser.add_argument(
        "--mano_hand_model_path",
        type=str,
        default=None,
        help="Path to MANO hand model directory (not needed for skeletal visualization)",
    )
    parser.add_argument(
        "--rrd_output",
        type=str,
        default="touch_events.rrd",
        help="Optional path to save .rrd file for later viewing",
    )
    parser.add_argument(
        "-n",
        "--num_events",
        type=int,
        default=10,
        help="Number of touch events to visualize (default: all events)",
    )
    
    args = parser.parse_args()
    
    if not os.path.exists(args.json_filepath):
        raise FileNotFoundError(f"JSON file not found: {args.json_filepath}")
    
    if not os.path.exists(args.object_library_folder):
        raise FileNotFoundError(f"Object library folder not found: {args.object_library_folder}")
    
    visualize_touch_events(
        json_filepath=args.json_filepath,
        object_library_folder=args.object_library_folder,
        mano_hand_model_path=args.mano_hand_model_path,
        rrd_output_path=args.rrd_output,
        num_events=args.num_events,
    )


if __name__ == "__main__":
    main()

